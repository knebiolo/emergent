.........EE...EEEEEEEEEEEEE.....                                         [100%]
=================================== ERRORS ====================================
_ ERROR at setup of test_extract_centerline_hecras_returns_none_for_small_plan _

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E460E1E40>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
_ ERROR at setup of test_extract_centerline_hecras_raises_on_missing_datasets _

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E49A3BCE0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
__________________ ERROR at setup of test_hecras_map_nearest __________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E49A3AF20>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
________________ ERROR at setup of test_hecras_map_idw_weights ________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E49FF53A0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
________ ERROR at setup of test_infer_wetted_perimeter_raster_fallback ________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E49FF5620>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
_________ ERROR at setup of test_infer_wetted_perimeter_vector_basic __________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E49FF5760>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
_______ ERROR at setup of test_infer_wetted_perimeter_vector_no_wetted ________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E460E1E40>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
______________ ERROR at setup of test_ensure_hdf_coords_and_map _______________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E499EBEC0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
______________ ERROR at setup of test_map_raises_when_no_adapter ______________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E447A63E0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
_______ ERROR at setup of test_map_hecras_for_agents_with_fake_adapter ________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E499EBEC0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
_______ ERROR at setup of test_map_hecras_to_env_rasters_writes_rasters _______

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E49FF58A0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
____________________ ERROR at setup of test_hecrasmap_idw _____________________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E49FF5C60>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
___________ ERROR at setup of test_initialize_hecras_geometry_smoke ___________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E49FF5E40>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
_____________ ERROR at setup of test_strict_missing_field_raises ______________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E49FF5F80>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
___________ ERROR at setup of test_initialize_hecras_geometry_smoke ___________

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x0000029E49FF62A0>
when = 'setup'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.
    
        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        instant = timing.Instant()
        try:
>           result: TResult | None = func()
                                     ^^^^^^

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:245: in <lambda>
    lambda: runtest_hook(item=item, **kwds),
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\logging.py:843: in pytest_runtest_setup
    yield
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:165: in pytest_runtest_setup
    item.session._setupstate.setup(item)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\runner.py:523: in setup
    col.setup()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\python.py:1723: in setup
    self._request._fillfixtures()
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:707: in _fillfixtures
    item.funcargs[argname] = self.getfixturevalue(argname)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:539: in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:627: in _get_active_fixturedef
    fixturedef.execute(request=subrequest)
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1110: in execute
    result: FixtureValue = ihook.pytest_fixture_setup(
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\setuponly.py:36: in pytest_fixture_setup
    return (yield)
            ^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:1202: in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\fixtures.py:908: in call_fixture_func
    fixture_result = next(generator)
                     ^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:267: in tmp_path
    path = _mk_tmp(request, tmp_path_factory)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:254: in _mk_tmp
    return factory.mktemp(name, numbered=True)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:130: in mktemp
    basename = self._ensure_relative_to_basetemp(basename)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:111: in _ensure_relative_to_basetemp
    if (self.getbasetemp() / basename).resolve().parent != self.getbasetemp():
        ^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\tmpdir.py:186: in getbasetemp
    basetemp = make_numbered_dir_with_cleanup(
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:407: in make_numbered_dir_with_cleanup
    raise e
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:388: in make_numbered_dir_with_cleanup
    p = make_numbered_dir(root, prefix, mode)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:229: in make_numbered_dir
    max_existing = max(map(parse_num, find_suffixes(root, prefix)), default=-1)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:188: in extract_suffixes
    for entry in iter:
                 ^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

root = WindowsPath('C:/Users/Kevin.Nebiolo/AppData/Local/Temp/pytest-of-Kevin.Nebiolo')
prefix = 'pytest-'

    def find_prefixed(root: Path, prefix: str) -> Iterator[os.DirEntry[str]]:
        """Find all elements in root that begin with the prefix, case-insensitive."""
        l_prefix = prefix.lower()
>       for x in os.scandir(root):
                 ^^^^^^^^^^^^^^^^
E       PermissionError: [WinError 5] Access is denied: 'C:\\Users\\Kevin.Nebiolo\\AppData\\Local\\Temp\\pytest-of-Kevin.Nebiolo'

..\..\..\.conda\envs\emergent\Lib\site-packages\_pytest\pathlib.py:176: PermissionError
=========================== short test summary info ===========================
ERROR src/emergent/fish_passage/tests/test_extract_centerline_hecras_wrapper.py::test_extract_centerline_hecras_returns_none_for_small_plan
ERROR src/emergent/fish_passage/tests/test_extract_centerline_hecras_wrapper.py::test_extract_centerline_hecras_raises_on_missing_datasets
ERROR src/emergent/fish_passage/tests/test_hecras_map.py::test_hecras_map_nearest
ERROR src/emergent/fish_passage/tests/test_hecras_map.py::test_hecras_map_idw_weights
ERROR src/emergent/fish_passage/tests/test_infer_wetted_perimeter_raster.py::test_infer_wetted_perimeter_raster_fallback
ERROR src/emergent/fish_passage/tests/test_infer_wetted_perimeter_vector.py::test_infer_wetted_perimeter_vector_basic
ERROR src/emergent/fish_passage/tests/test_infer_wetted_perimeter_vector.py::test_infer_wetted_perimeter_vector_no_wetted
ERROR src/emergent/fish_passage/tests/test_io.py::test_ensure_hdf_coords_and_map
ERROR src/emergent/fish_passage/tests/test_io.py::test_map_raises_when_no_adapter
ERROR src/emergent/fish_passage/tests/test_io_adapter.py::test_map_hecras_for_agents_with_fake_adapter
ERROR src/emergent/fish_passage/tests/test_io_adapter.py::test_map_hecras_to_env_rasters_writes_rasters
ERROR src/emergent/fish_passage/tests/test_io_hecras.py::test_hecrasmap_idw
ERROR src/emergent/fish_passage/tests/test_io_hecras.py::test_initialize_hecras_geometry_smoke
ERROR src/emergent/fish_passage/tests/test_io_missing_field_strict.py::test_strict_missing_field_raises
ERROR src/emergent/fish_passage/tests/test_io_skeleton.py::test_initialize_hecras_geometry_smoke
17 passed, 15 errors in 5.19s
